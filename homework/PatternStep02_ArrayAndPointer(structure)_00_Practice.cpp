//=========================================================================================
// 01번-09. 구조체 함수 변환
//=========================================================================================
// 01번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
struct _SData
{
	char a1, a2;
};
typedef struct _SData SData;

SData inputData(SData);
SData printData(SData);

int main(void)
{
	SData x;
	x.a1 = '0';
	(&x)->a2 = '0';

	x = inputData(x);
	x = printData(x);
	return 0;
}

SData inputData(SData x)
{
	scanf(" %c %c", &(x.a1), &((&x)->a2));
	return x;
}

SData printData(SData x)
{
	puts("문자 상소의 표현과 출력");
	printf("%c", x.a1);
	printf("%c", (&x)->a2);
	return x;
}
#endif

//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------
#if 0
#include <cstdio>

typedef struct _SData
{
	char a1, a2;
	struct _SData inputData(struct _SData);
	struct _SData printData(struct _SData);
}SData;

SData SData::inputData(SData x)
{
	scanf(" %c %c", &(x.a1), &((&x)->a2));
	return x;
}
SData SData::printData(SData x)
{
	puts("정수 상수의 표현과 출력");
	printf("%c", x.a1);
	printf("%c", (&x)->a2);
	return x;
}

int main(void) {
	// -------입력-변수 선언------------------------------
	SData x;
	// -------입력-변수 초기화----------------------------
	x.a1 = '0';
	(&x)->a2 = '0';

	x = x.inputData(x);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = x.printData(x);
	return 0;
}

#endif

//=========================================================================================
// 01번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
typedef struct _SData
{
	char a1, a2;
}SData;

SData* inputData(SData*);
SData* printData(SData*);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData x;

	// -------입력-변수 초기화----------------------------
	x.a1 = '0';
	(&x)->a2 = '0';

	x = *(inputData(&x));

	// -------처리----------------------------------------
	// -------출력----------------------------------------

	x = *(printData(&x));
	return 0;
}

SData* inputData(SData* x)
{
	scanf(" %c %c", &((*x).a1), &(x->a2));
	return x;
}

SData* printData(SData* x)
{
	puts("문자 상소의 표현과 출력");
	printf("%c", (*x).a1);
	printf("%c", x->a2);
	return x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------
// case 3. call-by-reference
#if 0
#include <stdio.h>
struct _SData
{
	char a1, a2;
};
typedef struct _SData SData;

SData& inputData(SData&);
SData& printData(SData&);

int main(void)
{
	SData x;
	x.a1 = '0';
	(&x)->a2 = '0';

	x = inputData(x);
	x = printData(x);
	return 0;
}

SData& inputData(SData& x)
{
	scanf(" %c %c", &(x.a1), &((&x)->a2));
	return x;
}

SData& printData(SData& x)
{
	puts("문자 상소의 표현과 출력");
	printf("%c", x.a1);
	printf("%c", (&x)->a2);
	return x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#define ColSize 2

typedef struct _SData
{
	char a1, a2;
}SData;

SData& inputData(SData[ColSize], int, int);
SData* printData(SData[ColSize], int, int);

int main(void)
{
	SData x[ColSize];
	int i, CSize;

	i = 0;
	CSize = ColSize;

	*x = inputData(x, i, CSize);
	*x = *printData(x, i, CSize);
	return 0;
}

SData& inputData(SData x[ColSize], int i, int CSize)
{
	for (i = 0; i < CSize; i++)
	{
		scanf(" %c %c", &(x[i].a1), &(x[i].a2));

	}
	//return (x + 0);
	return *x;
}

SData* printData(SData x[ColSize], int i, int CSize)
{
	puts("문자 상소의 표현과 출력");
	for (i = 0; i < CSize; i++)
	{
		printf("%c", x[i].a1);
		printf("%c", x[i].a2);
	}
	return x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#include <malloc.h>
#define ColSize 2

typedef struct _SData
{
	char a1, a2;
}SData;

SData* inputData(SData*, int, int);
SData& printData(SData*, int, int);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData* x;
	int i, CSize;

	// -------입력-변수 초기화----------------------------
	x = (SData*)malloc(sizeof(SData) * ColSize);
	i = 0;
	CSize = ColSize;

	*x = *(inputData(x, i, CSize));
	// -------처리----------------------------------------
	// -------출력----------------------------------------

	*x = printData(x, i, CSize);
	return 0;
}

SData* inputData(SData* x, int i, int CSize)
{
	for (i = 0; i < CSize; i++)
	{
		scanf(" %c %c", &(x[i].a1), &(x[i].a2));
	}
	//return (x + 0);
	return x;
}

SData& printData(SData* x, int i, int CSize)
{
	puts("문자 상소의 표현과 출력");
	for (i = 0; i < CSize; i++)
	{
		printf("%c", x[i].a1);
		printf("%c", x[i].a2);
	}
	return *x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#define RowSize 1
#define ColSize 2

typedef struct _SData
{
	char a1, a2;
}SData;

SData* inputData(SData[RowSize][ColSize], int, int, int, int);
SData& printData(SData[RowSize][ColSize], int, int, int, int);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData x[RowSize][ColSize];
	int i, j, RSize, CSize;


	// -------입력-변수 초기화----------------------------
	i = j = 0;
	RSize = RowSize;
	CSize = ColSize;
	**x = *(inputData(x, i, j, RSize, CSize));
	// -------처리----------------------------------------
	// -------출력----------------------------------------
	**x = printData(x, i, j, RSize, CSize);
	return 0;
}

SData* inputData(SData x[RowSize][ColSize], int i, int j, int RSize, int CSize)
{
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			scanf(" %c %c", &(x[i][j].a1), &(x[i][j].a2));
		}
	}
	//return (x + 0);
	return *x;
}

SData& printData(SData x[RowSize][ColSize], int i, int j, int RSize, int CSize)
{
	puts("문자 상소의 표현과 출력");
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			printf("%c", x[i][j].a1);
			printf("%c", x[i][j].a2);
		}
	}
	return **x;
}
#endif



//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#include <malloc.h>
#define RowSize 1
#define ColSize 2

typedef struct _SData
{
	char a1, a2;
}SData;

SData* inputData(SData* [RowSize], int, int, int, int);
SData& printData(SData* [RowSize], int, int, int, int);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData* x[RowSize];
	int i, j, RSize, CSize;


	// -------입력-변수 초기화----------------------------
	for (i = 0; i < RowSize; i++)
	{
		x[i] = (SData*)malloc(sizeof(SData) * ColSize);
	}
	i = j = 0;
	RSize = RowSize;
	CSize = ColSize;
	//**x = *(inputData(x, i, j, RSize, CSize));
	*x = inputData(x, i, j, RSize, CSize);
	// -------처리----------------------------------------
	// -------출력----------------------------------------
	*x = &(printData(x, i, j, RSize, CSize));
	for (i = 0; i < RowSize; i++)
	{
		free(x[i]);
	}
	return 0;
}

SData* inputData(SData* x[RowSize], int i, int j, int RSize, int CSize)
{
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			scanf(" %c %c", &(x[i][j].a1), &(x[i][j].a2));
		}
	}
	//return (x + 0);
	return *x;
}

SData& printData(SData* x[RowSize], int i, int j, int RSize, int CSize)
{
	puts("문자 상소의 표현과 출력");
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			printf("%c", x[i][j].a1);
			printf("%c", x[i][j].a2);
		}
	}
	return **x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 01번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>

void inputData(int&, int&, int&, double&, double&, double&);
void printData(int&, int&, int&, double&, double&, double&);
int main(void)
{
	// -------입력-변수 선언------------------------------
	int x1, x2, x3;
	double y1, y2, y3;

	// -------입력-변수 초기화----------------------------
	inputData(x1, x2, x3, y1, y2, y3);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	printData(x1, x2, x3, y1, y2, y3);
	return 0;
}
void inputData(int& x1, int& x2, int& x3, double& y1, double& y2, double& y3)
{
	scanf("%d%d%d", &x1, &x2, &x3);
	scanf("%lf%lf%lf", &y1, &y2, &y3);
	return;
}
void printData(int& x1, int& x2, int& x3, double& y1, double& y2, double& y3)
{
	printf("정수 상수의 표현과 출력\n");
	printf("%d ", x1);
	printf("%d ", x2);
	printf("%d ", x3);

	printf("실수 상수의 표현과 출력\n");
	printf("%lf ", y1);
	printf("%lf ", y2);
	printf("%lf ", y3);
	return;
}
#endif

//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 01번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#include <malloc.h>
#define RowSize 1
#define ColSize 2

typedef struct _SData
{
	char a1, a2;
}SData;

SData* inputData(SData**, int, int, int, int);
SData& printData(SData**, int, int, int, int);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData** x;
	int i, j, RSize, CSize;


	// -------입력-변수 초기화----------------------------
	x = (SData * *)malloc(sizeof(SData*) * RowSize);
	for (i = 0; i < RowSize; i++)
	{
		x[i] = (SData*)malloc(sizeof(SData) * ColSize);
	}
	i = j = 0;
	RSize = RowSize;
	CSize = ColSize;

	**x = *(inputData(x, i, j, RSize, CSize));
	*x = inputData(x, i, j, RSize, CSize);
	// -------처리----------------------------------------
	// -------출력----------------------------------------
	**x = printData(x, i, j, RSize, CSize);
	*x = &printData(x, i, j, RSize, CSize);

	for (i = 0; i < RowSize; i++)
	{
		free(x[i]);
	}
	free(x);
	return 0;
}

SData* inputData(SData** x, int i, int j, int RSize, int CSize)
{
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			scanf(" %c %c", &(x[i][j].a1), &(x[i][j].a2));
		}
	}
	//return (x + 0);
	return *x;
}

SData& printData(SData** x, int i, int j, int RSize, int CSize)
{
	puts("문자 상소의 표현과 출력");
	for (i = 0; i < RSize; i++)
	{
		for (j = 0; j < CSize; j++)
		{
			printf("%c", x[i][j].a1);
			printf("%c", x[i][j].a2);
		}
	}
	return **x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 01번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.
TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 01번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 01번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 01번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 01번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 01번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif










//=========================================================================================
// 02번-09. 구조체 함수 변환
//=========================================================================================
// 02번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>

struct _SData
{
	int x1, x2, x3;
	double y1, y2, y3;
};
typedef struct _SData SData;

SData inputData(SData);
SData printData(SData);

int main(void)
{
	// -------입력-변수 선언------------------------------

	SData x;


	// -------입력-변수 초기화----------------------------
	x = inputData(x);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = printData(x);
	return 0;
}
SData inputData(SData x)
{
	scanf("%d%d%d", &(x.x1), &(x.x2), &(x.x3));
	scanf("%lf%lf%lf", &((&x)->y1), &((&x)->y2), &((&x)->y3));
	return x;
}
SData printData(SData x)
{
	printf("정수 상수의 표현과 출력\n");
	printf("%d ", x.x1);
	printf("%d ", x.x2);
	printf("%d ", x.x3);

	printf("실수 상수의 표현과 출력\n");
	printf("%lf ", (&x)->y1);
	printf("%lf ", (&x)->y2);
	printf("%lf ", (&x)->y3);
	return x;
}
#endif

//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------
#if 0
#include <cstdio>

typedef struct _SData
{
	int x1, x2, x3;
	double y1, y2, y3;
	struct _SData inputData(struct _SData);
	struct _SData printData(struct _SData);
}SData;

SData SData::inputData(SData x)
{
	scanf("%d%d%d", &(x.x1), &(x.x2), &(x.x3));
	scanf("%lf%lf%lf", &((&x)->y1), &((&x)->y2), &((&x)->y3));
	return x;
}

SData SData::printData(SData x)
{
	printf("정수 상수의 표현과 출력\n");
	printf("%d ", x.x1);
	printf("%d ", x.x2);
	printf("%d ", x.x3);

	printf("실수 상수의 표현과 출력\n");
	printf("%lf ", (&x)->y1);
	printf("%lf ", (&x)->y2);
	printf("%lf ", (&x)->y3);
	return x;
}

int main(void)
{
	// -------입력-변수 선언------------------------------

	SData x;


	// -------입력-변수 초기화----------------------------
	x = x.inputData(x);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = x.printData(x);
	return 0;
}


#endif

//=========================================================================================
// 02번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>

typedef struct _SData
{
	int x1, x2, x3;
	double y1, y2, y3;
}SData;

SData* inputData(SData*);
SData* printData(SData*);

int main(void)
{
	// -------입력-변수 선언------------------------------

	SData x;


	// -------입력-변수 초기화----------------------------
	x = *(inputData(&x));

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = *(printData(&x));
	return 0;
}
SData* inputData(SData* x)
{
	scanf("%d%d%d", &((*x).x1), &((*x).x2), &((*x).x3));
	scanf("%lf%lf%lf", &(x->y1), &(x->y2), &(x->y3));
	return x;
}
SData* printData(SData* x)
{
	printf("정수 상수의 표현과 출력\n");
	printf("%d ", (*x).x1);
	printf("%d ", (*x).x2);
	printf("%d ", (*x).x3);

	printf("실수 상수의 표현과 출력\n");
	printf("%lf ", x->y1);
	printf("%lf ", x->y2);
	printf("%lf ", x->y3);
	return x;
}
#endif

//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>

struct _SData
{
	int x1, x2, x3;
	double y1, y2, y3;
};
typedef struct _SData SData;

SData& inputData(SData&);
SData& printData(SData&);

int main(void)
{
	// -------입력-변수 선언------------------------------

	SData x;


	// -------입력-변수 초기화----------------------------
	x = inputData(x);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = printData(x);
	return 0;
}
SData& inputData(SData& x)
{
	scanf("%d%d%d", &(x.x1), &(x.x2), &(x.x3));
	scanf("%lf%lf%lf", &((&x)->y1), &((&x)->y2), &((&x)->y3));
	return x;
}
SData& printData(SData& x)
{
	printf("정수 상수의 표현과 출력\n");
	printf("%d ", x.x1);
	printf("%d ", x.x2);
	printf("%d ", x.x3);

	printf("실수 상수의 표현과 출력\n");
	printf("%lf ", (&x)->y1);
	printf("%lf ", (&x)->y2);
	printf("%lf ", (&x)->y3);
	return x;
}
#endif


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>
#define ColSize 2

typedef struct _SData
{
	int x1, x2, x3;
	double y1, y2, y3;
}SData;

SData& inputData(SData[ColSize], int, int);
SData* printData(SData[ColSize], int, int);

int main(void)
{
	// -------입력-변수 선언------------------------------

	SData x[ColSize];
	int i, CSize;


	// -------입력-변수 초기화----------------------------
	i = 0;
	CSize = ColSize;

	*x = inputData(x, i, CSize);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	*x = *(printData(x, i, CSize));
	return 0;
}
SData& inputData(SData x[ColSize], int i, int CSize)
{
	for (i = 0; i < CSize; i++)
	{
		/*scanf("%d%d%d", &(x[i].x1), &(x[i].x2), &(x[i].x3));
		scanf("%lf%lf%lf", &(x[i].y1), &(x[i].y2), &(x[i].y3));*/
		/*scanf("%d%d%d", &((*(x+i)).x1), &((*(x+i)).x2), &((*(x+i)).x3));
		scanf("%lf%lf%lf", &((*(x+i)).y1), &((*(x+i)).y2), &((*(x+i)).y3));*/
		scanf("%d%d%d", &((x + i)->x1), &((x + i)->x2), &((x + i)->x3));
		scanf("%lf%lf%lf", &((x + i)->y1), &((x + i)->y2), &((x + i)->y3));
	}
	return *x;
}
SData* printData(SData x[ColSize], int i, int CSize)
{

	for (i = 0; i < CSize; i++)
	{
		printf("정수 상수의 표현과 출력\n");
		/*printf("%d ", x[i].x1);
		printf("%d ", x[i].x2);
		printf("%d ", x[i].x3);*/
		printf("%d ", (*(x + i)).x1);
		printf("%d ", (*(x + i)).x2);
		printf("%d ", (*(x + i)).x3);


		printf("실수 상수의 표현과 출력\n");
		printf("%lf ", (x + i)->y1);
		printf("%lf ", (x + i)->y2);
		printf("%lf ", (x + i)->y3);

	}
	return x;
}
#endif

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 02번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);


//=========================================================================================
// 02번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 
TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif


//=========================================================================================
// 02번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif


//=========================================================================================
// 02번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 02번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 02번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif


//=========================================================================================
// 02번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif











//=========================================================================================
// 03번-09. 구조체 함수 변환
//=========================================================================================
// 03번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------
#if 0
#include <stdio.h>

struct _SData
{
	int age;
};
typedef struct _SData SData;


SData inputData(SData);
SData printData(SData);

int main(void)
{
	// -------입력-변수 선언------------------------------
	SData x;
	// -------입력-변수 초기화----------------------------
	x.age = 0;
	x = inputData(x);

	// -------처리----------------------------------------
	// -------출력----------------------------------------
	x = printData(x);

	return 0;
}
SData inputData(SData x) {
	//scanf("%d", &(x.age));
	scanf("%d", &((&x)->age));
	return x;
}

SData printData(SData x) {
	//printf("%d\n", x.age);
	printf("%d\n", (&x)->age);
	return x;
}

#endif

//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 03번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 03번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 03번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 03번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 03번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 03번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 03번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 03번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 04번-09. 구조체 함수 변환
//=========================================================================================
// 04번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 04번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 04번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 04번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 04번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 04번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 04번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 04번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 04번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 05번-09. 구조체 함수 변환
//=========================================================================================
// 05번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 05번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 05번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 05번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 05번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 05번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 05번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 05번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 05번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 06번-09. 구조체 함수 변환
//=========================================================================================
// 06번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 06번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 06번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 06번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 06번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 06번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 06번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 06번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 06번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 07번-09. 구조체 함수 변환
//=========================================================================================
// 07번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 07번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 07번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 07번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 07번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 07번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 07번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 07번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 07번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 08번-09. 구조체 함수 변환
//=========================================================================================
// 08번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 08번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 08번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 08번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 08번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 08번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 08번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 08번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 08번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif












//=========================================================================================
// 09번-09. 구조체 함수 변환
//=========================================================================================
// 09번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 09번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 09번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 09번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 09번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 09번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 09번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 09번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 09번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 10번-09. 구조체 함수 변환
//=========================================================================================
// 10번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 10번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 10번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 10번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 10번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 10번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 10번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 10번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 10번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 11번-09. 구조체 함수 변환
//=========================================================================================
// 11번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 11번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 11번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 11번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 11번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 11번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 11번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 11번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 11번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 12번-09. 구조체 함수 변환
//=========================================================================================
// 12번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 12번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 12번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 12번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 12번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 12번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 12번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 12번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 12번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 13번-09. 구조체 함수 변환
//=========================================================================================
// 13번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 13번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 13번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 13번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 13번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 13번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 13번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 13번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 13번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 14번-09. 구조체 함수 변환
//=========================================================================================
// 14번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 14번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 14번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 14번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 14번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 14번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 14번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 14번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 14번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 15번-09. 구조체 함수 변환
//=========================================================================================
// 15번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 15번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 15번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 15번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 15번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 15번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 15번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 15번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 15번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 16번-09. 구조체 함수 변환
//=========================================================================================
// 16번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 16번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 16번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 16번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 16번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 16번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 16번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 16번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 16번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 17번-09. 구조체 함수 변환
//=========================================================================================
// 17번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 17번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 17번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 17번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 17번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 17번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 17번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 17번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 17번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 18번-09. 구조체 함수 변환
//=========================================================================================
// 18번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 18번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 18번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 18번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 18번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 18번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 18번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 18번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 18번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 19번-09. 구조체 함수 변환
//=========================================================================================
// 19번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 19번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 19번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 19번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 19번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 19번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 19번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 19번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 19번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 20번-09. 구조체 함수 변환
//=========================================================================================
// 20번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 20번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 20번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 20번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 20번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 20번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 20번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 20번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 20번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 21번-09. 구조체 함수 변환
//=========================================================================================
// 21번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 21번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 21번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 21번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 21번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 21번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 21번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 21번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 21번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 22번-09. 구조체 함수 변환
//=========================================================================================
// 22번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 22번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 22번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 22번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 22번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 22번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 22번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 22번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 22번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 23번-09. 구조체 함수 변환
//=========================================================================================
// 23번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 23번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 23번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 23번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 23번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 23번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 23번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 23번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 23번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 24번-09. 구조체 함수 변환
//=========================================================================================
// 24번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 24번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 24번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 24번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 24번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 24번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 24번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 24번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 24번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 25번-09. 구조체 함수 변환
//=========================================================================================
// 25번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 25번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 25번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 25번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 25번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 25번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 25번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 25번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 25번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 26번-09. 구조체 함수 변환
//=========================================================================================
// 26번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 26번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 26번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 26번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 26번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 26번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 26번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 26번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 26번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 27번-09. 구조체 함수 변환
//=========================================================================================
// 27번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 27번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 27번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 27번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 27번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 27번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 27번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 27번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 27번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 28번-09. 구조체 함수 변환
//=========================================================================================
// 28번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 28번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 28번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 28번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 28번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 28번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 28번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 28번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 28번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 29번-09. 구조체 함수 변환
//=========================================================================================
// 29번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 29번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 29번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 29번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 29번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 29번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 29번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 29번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 29번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 30번-09. 구조체 함수 변환
//=========================================================================================
// 30번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 30번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 30번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 30번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 30번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 30번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 30번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 30번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 30번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 31번-09. 구조체 함수 변환
//=========================================================================================
// 31번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 31번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 31번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 31번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 31번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 31번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 31번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 31번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 31번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 32번-09. 구조체 함수 변환
//=========================================================================================
// 32번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 32번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 32번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 32번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 32번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 32번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 32번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 32번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 32번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 33번-09. 구조체 함수 변환
//=========================================================================================
// 33번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 33번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 33번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 33번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 33번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 33번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 33번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 33번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 33번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 34번-09. 구조체 함수 변환
//=========================================================================================
// 34번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 34번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 34번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 34번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 34번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 34번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 34번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 34번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 34번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 35번-09. 구조체 함수 변환
//=========================================================================================
// 35번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 35번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 35번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 35번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 35번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 35번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 35번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 35번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 35번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif
















//=========================================================================================
// 36번-09. 구조체 함수 변환
//=========================================================================================
// 36번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 36번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 36번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 36번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 36번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 36번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 36번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 36번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 36번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 37번-09. 구조체 함수 변환
//=========================================================================================
// 37번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 37번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 37번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 37번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 37번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 37번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 37번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 37번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 37번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 38번-09. 구조체 함수 변환
//=========================================================================================
// 38번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 38번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 38번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 38번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 38번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 38번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 38번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 38번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 38번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 39번-09. 구조체 함수 변환
//=========================================================================================
// 39번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 39번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 39번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 39번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 39번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 39번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 39번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 39번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 39번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 40번-09. 구조체 함수 변환
//=========================================================================================
// 40번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 40번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 40번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 40번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 40번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 40번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 40번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 40번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 40번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 41번-09. 구조체 함수 변환
//=========================================================================================
// 41번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 41번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 41번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 41번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 41번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 41번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 41번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 41번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 41번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 42번-09. 구조체 함수 변환
//=========================================================================================
// 42번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 42번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 42번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 42번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 42번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 42번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 42번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 42번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 42번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 43번-09. 구조체 함수 변환
//=========================================================================================
// 43번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 43번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 43번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 43번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 43번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 43번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 43번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 43번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 43번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 44번-09. 구조체 함수 변환
//=========================================================================================
// 44번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 44번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 44번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 44번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 44번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 44번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 44번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 44번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 44번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 45번-09. 구조체 함수 변환
//=========================================================================================
// 45번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 45번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 45번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 45번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 45번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 45번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 45번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 45번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 45번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 46번-09. 구조체 함수 변환
//=========================================================================================
// 46번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 46번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 46번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 46번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 46번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 46번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 46번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 46번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 46번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif















//=========================================================================================
// 47번-09. 구조체 함수 변환
//=========================================================================================
// 47번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 47번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 47번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 47번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 47번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 47번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 47번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 47번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 47번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif













//=========================================================================================
// 48번-09. 구조체 함수 변환
//=========================================================================================
// 48번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 48번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 48번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 48번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 48번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 48번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 48번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 48번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 48번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 49번-09. 구조체 함수 변환
//=========================================================================================
// 49번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 49번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 49번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 49번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 49번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 49번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 49번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 49번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 49번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif














//=========================================================================================
// 50번-09. 구조체 함수 변환
//=========================================================================================
// 50번-09-1. call-by-value
//=========================================================================================
// case 1. 구조체와 typdef을 분리하여 선언한 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 구조체와 typdef을 결합하여  선언한 경우
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-09-2. call-by-address
//=========================================================================================
// case 1. 함수의 반환값을 call by address로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-09-3. call-by-reference
//=========================================================================================
// case 1. 함수의 반환값을 Call by reference 방식으로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-10. 구조체 1차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-11. 구조체 1차원 배열 - 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-12. 구조체 2차원 배열
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-13. 구조체 2차원 배열 - 포인터 배열 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 50번-14. 구조체 2차원 배열 - 배열 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
// 배열 포인터에서는 2차원 주소를 반환하는 형태의 코드는 지원되지 않음. 
//TData** inputdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);
//TData&  printdata(TData (*Number)[ColSize], int i, int j, int RSize, int CSize);



//=========================================================================================
// 50번-15. 구조체 2차원 배열 - 이중 포인터 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 50번-16. 구조체 3차원 배열 
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 함수 반환값 2차원 주소를 반환하는 형태는 지원되지 않음.

TData * *inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return *(Number+0)+0);
	//return *(Number+0);
	//return *(Number);
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 아래의 코드와 같이 3차원 배열이 선언되어 있는 경우에는 3차원의 시작주소를 반환하는 형태로
// 함수의 반환값을 반환할 수 없음. 

TData * **inputdata(TData[PageSize][RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData Number[PageSize][RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 50번-17. 구조체 3차원 배열 - 구조체 포인터2차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 3차원의 주소를 반환하는 형태는 포인터 2차원 배열에서는 지원되지 않음. 
TData * **inputdata(TData * [PageSize][RowSize], int, int, int, int, int, int);
TData*** inputdata(TData* Number[PageSize][RowSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 50번-18. 구조체 3차원 배열- 구조체 이중포인터1차원배열로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------



//=========================================================================================
// 50번-19. 구조체 3차원 배열- 구조체 삼중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------


//=========================================================================================
// 50번-20. 구조체 3차원 배열- 구조체 2차원배열포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (*(Number+0)+0));
	//return (*(Number+0));
	//return (*(Number));
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 2차원 배열 포인터에서 3차원 주소를 반환하는 형태는 지원되지 않음.
TData * **inputdata(TData(*)[RowSize][ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(*Number)[RowSize][ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	//return (Number+0);
	return Number;
}
#endif

//=========================================================================================
// 50번-21. 구조체 3차원 배열- 구조체 1차원배열이중포인터로 변환
//=========================================================================================
// case 1. 함수의 반환값을 call by value로 반환하는 경우 
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 2. 함수의  반환값을 call by address/reference로 반환하는 경우 - 1차원 주소를 반환
//-----------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------
// case 3. 함수의  반환값을 call by address/reference로 반환하는 경우 - 2차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 2차원 주소를 반환하는 형태는 지원되지 않음. 
TData * *inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return *Number;
}
#endif

//-----------------------------------------------------------------------------------------
// case 4. 함수의  반환값을 call by address/reference로 반환하는 경우 - 3차원 주소를 반환 
//-----------------------------------------------------------------------------------------
#if 0
// 1차원배열이중포인터에서는 3차원 주소를 반환하는 형태는 지원되지 않음. 
TData * **inputdata(TData(**)[ColSize], int, int, int, int, int, int);
TData*** inputdata(TData(**Number)[ColSize], int i, int j, int k, int PSize, int RSize, int CSize)
{
	for (i = 0; i < PSize; i++)
	{
		for (j = 0; j < RSize; j++)
		{
			for (k = 0; k < CSize; k++)
			{
				//scanf("%lf", &(Number[i][j][k].RATE));
				//scanf("%lf", &((*(Number[i][j]+k)).RATE));
				//scanf("%lf", &((*(*(Number[i]+j) + k)).RATE));
				//scanf("%lf", &((*(*(*(Number+i) + j) + k)).RATE));
				//scanf("%lf", &((Number[i][j]+k)->RATE));
				//scanf("%lf", &((*(Number[i]+j) + k)->RATE));
				scanf("%lf", &((*(*(Number + i) + j) + k)->RATE));

				scanf("%d", &(Number[i][j][k].MIN_BALANCE));
			}
		}
	}
	return Number;
}
#endif
